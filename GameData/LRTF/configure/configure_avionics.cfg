// To keep config clutter down, TF settings are abstracted into a LRTFAVIONICS block.
// The syntax is as follows:
// LRTFAVIONICS {
//     // required
//     name =                           // configuration name. MUST be unique to each part!
//     cycleReliabilityStart =          // probability of surviving an orbit at 0 DU
//     cycleReliabilityEnd =            // probability at max DU
//     startMTBF =                      //MTBF for new parts
//     duPerFlight =                    //du collected per flight
//     avionicsAxis = 					//true enables each failure mode
//     avionicsClamp = 
//     avionicsDeadZone = 
//     avionicsGlitch = 
//     avionicsInvert = 
//     avionicsPartial = 
//     avionicsThrustJam = 
//     avionicsTotal = 
//     avionicsReactionWheel =
//     avionicsBattery =
//
//     // optional
//     title =                          // part name to use in MFD. Defaults to full VAB name.
//     mannedMulti =                    //duFail and repair multiple for manned command parts
//     startFlightData =                // minimum DU a part may have. Default 0.
//     techTransfer =                   // other parts produce data for this one
//     reliabilityDataRateMultiplier =  // data collection efficiency (default 1.0)
//     explicitDataRate = True          // reliabilityDataRateMultiplier is data rate per second.
//     maxDeadtime =  1            //max time loss of control can happen before toggling back on
//     maxWorktime =  1           //max time working control can happen before toggling off
//     drainResource =            //drains all pump failer resources to 0
//
//     mainConfiguration =              // override for configurable command parts
//     reliabilityMidH =                // midpoint data value. 0.0 means 1000 DU, 1.0 means 6000 DU. Default 0.75 (4750 DU).
// }

// Handle TF interop
@PART[*]:HAS[@LRTFAVIONICS,@MODULE[TestFlightInterop]]:FOR[zTestFlight]
{
        !LRTFAVIONICS,* {} // something else is configuring TF, so don't do it.
}

// Preprocess
@PART[*]:HAS[@LRTFAVIONICS]:FOR[zTestFlight]
{
        // Default values
        @LRTFAVIONICS
        {
                alias = #$name$
                displayName = #$../title$
                temp = #$../name$
                @temp ^= :_:-:
                mainConf = #kspPartName = $temp$:$alias$

                kinkH = 0.75

                dataMult = 1.0
                startDU = 0
                tech =  
                mannedDUMulti = 1
				glitchMaxDeadtime = 1
				glitchMaxWorktime = 1
        }

        // Let user override defaults
        @LRTFAVIONICS:HAS[#title[*]]
        {
                @displayName = #$title$
        }
        @LRTFAVIONICS:HAS[#mainConfiguration[*]]
        {
                // Assume no alias in mainConfiguration; otherwise overwrite below
                @mainConf = #$mainConfiguration$:$alias$
        }
        @LRTFAVIONICS:HAS[#mainConfiguration[*:*]]
        {
                @mainConf = #$mainConfiguration$
                @alias = #$mainConfiguration[1,:]$
        }
        @LRTFAVIONICS:HAS[#reliabilityMidH[*]]
        {
                @kinkH = #$reliabilityMidH$
        }
        @LRTFAVIONICS:HAS[#reliabilityDataRateMultiplier[*]]
        {
                @dataMult *= #$reliabilityDataRateMultiplier$
        }
        @LRTFAVIONICS:HAS[#startFlightData[*]]
        {
                @startDU = #$startFlightData$
        }
        @LRTFAVIONICS:HAS[#techTransfer[*]]
        {
                @tech = #$techTransfer$
        }
        @LRTFAVIONICS:HAS[~explicitDataRate[?rue]]
        {
                @dataMult *= #$duPerFlight$ // data collected per flight
                @dataMult /= #$startMTBF$
        }

		@LRLRTFAVIONICS:HAS[#maxDeadtime[*]]
		{
			%glitchMaxDeadtime = #$maxDeadtime$
		}
		@LRLRTFAVIONICS:HAS[#maxWorktime[*]]
		{
			%glitchMaxWorktime = #$maxWorktime$
		}
		@LRLRTFAVIONICS:HAS[#mannedMulti[*]]
		{
			%mannedDUMulti = #$mannedMulti$
		}
		

        // Convert fail chance to fail rate
        @LRTFAVIONICS
        {
                // should really be failChanceStart = -ln(cycleReliabilityStart)/startMTBF
                // but ModuleManager doesn't support natural logarithms
                // (1/cycleReliabilityStart-1)/(2*startMTBF) is an ok approximation
                failChanceStart = 1
                @failChanceStart /= #$cycleReliabilityStart$
                @failChanceStart -= 1
                @failChanceStart /= 2
                @failChanceStart /= #$startMTBF$
                failChanceEnd = 1
                @failChanceEnd /= #$cycleReliabilityEnd$
                @failChanceEnd -= 1
                @failChanceEnd /= 2
                @failChanceEnd /= #$startMTBF$
        }
}

//------------------------------------------------------------------
// Create the nodes.

@PART[*]:HAS[@LRTFAVIONICS]:FOR[zTestFlight]
{
		@description = #$description$ <br><br><b><color=orange>Rated Operational Time ~$LRTFAVIONICS/startMTBF$ seconds</color><br><br>

        MODULE
        {
                name = TestFlightCore
                title = #$../LRTFAVIONICS,0/displayName$
                configuration = #$../LRTFAVIONICS,0/mainConf$
                maxData = 10000

                startFlightData = #$../LRTFAVIONICS,0/startDU$
                techTransfer = #$../LRTFAVIONICS,0/tech$
                // Most part series have only 2-3 parts
                techTransferGenerationPenalty = 0.5

                // R&D parameters will be handled later
        }

        MODULE
        {
        		//custom TF recorder requires ElectricCharge to work
                name = LRTFDataRecorder_Avionics
                configuration = #$../LRTFAVIONICS,0/alias$
                flightDataMultiplier = #$../LRTFAVIONICS,0/dataMult$
                resourceName = ElectricCharge
        }

        MODULE
        {
                name = TestFlightReliability
                configuration = #$../LRTFAVIONICS,0/alias$
                reliabilityCurve
                {
                        // Create first key
                        key10 = 0
                        key11 = #$../../LRTFAVIONICS,0/failChanceStart$

                        // Calculate kink time
                        key20 = #$../../LRTFAVIONICS,0/kinkH$
                        @key20 *= 5000
                        @key20 += 1000

                        // Calculate kink value
                        key21 = #$../../LRTFAVIONICS,0/failChanceEnd$
                        @key21 -= #$../../LRTFAVIONICS,0/failChanceStart$
                        @key21 *= 0.75
                        @key21 += #$../../LRTFAVIONICS,0/failChanceStart$

                        // Calculate kink tangent
                        key22 = #$../../LRTFAVIONICS,0/failChanceEnd$
                        @key22 -= #$../../LRTFAVIONICS,0/failChanceStart$
                        @key22 *= 0.0001
                        @key22 *= 0.5
                        // now average it with the linear tangent to the endpoint
                        key221 = #$../../LRTFAVIONICS,0/failChanceEnd$
                        @key221 -= #$key21$
                        key222 = 10000
                        @key222 -= #$key20$
                        @key221 /= #$key222$
                        @key222 = 0.5
                        @key222 *= -1
                        @key222 += 1
                        @key221 *= #$key222$
                        @key22 += #$key221$

                        // Create end key
                        key30 = 10000
                        key31 = #$../../LRTFAVIONICS,0/failChanceEnd$
                        key32 = 0 // flat intangent

                        // Create the keys
                        key = #$key10$ $key11$
                        key = #$key20$ $key21$ $key22$ $key22$
                        key = #$key30$ $key31$ $key32$ $key32$

                        // Clean up
                        !key10 = DEL
                        !key11 = DEL
                        !key20 = DEL
                        !key21 = DEL
                        !key22 = DEL
                        !key30 = DEL
                        !key31 = DEL
                        !key32 = DEL
                        !key221 = DEL
                        !key222 = DEL
                }
        }
}

@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsSAS[?rue]]]:FOR[zTestFlight]
{
		MODULE
        {
                name = LRTFFailure_AvionicsSAS
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = SAS Failure
                severity = minor
                weight = 8
                failureType = software
        }
}
@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsAxis[?rue]]]:FOR[zTestFlight]
{
        MODULE
        {
                name = LRTFFailure_AvionicsAxis
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = Loss Of Axial Control
                severity = minor
                weight = 8
                failureType = software
        }
}
@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsClamp[?rue]]]:FOR[zTestFlight]
{
        MODULE
        {
                name = LRTFFailure_AvionicsClamp
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = Avionics Clammped
                severity = minor
                weight = 8
                failureType = software
        }
}
@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsDeadZone[?rue]]]:FOR[zTestFlight]
{
        MODULE
        {
                name = LRTFFailure_AvionicsDeadzone
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = Avionics Dead Zone
                severity = minor
                weight = 16
                failureType = software
        }
}

@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsGlitch[?rue]]]:FOR[zTestFlight]
{
        MODULE
        {
                name = LRTFFailure_AvionicsGlitch
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = Avionics Glitch
                severity = minor
                weight = 16
                failureType = software
                maxDeadtime = #$../LRTFAVIONICS,0/glitchMaxDeadtime$
                maxWorkTime = #$../LRTFAVIONICS,0/glitchMaxWorktime$
        }
}
@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsInvert[?rue]]]:FOR[zTestFlight]
{
        MODULE
        {
                name = LRTFFailure_AvionicsInvert
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = Inverted Avionics
                severity = minor
                weight = 16
                failureType = hardware
        }
}
@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsPartial[?rue]]]:FOR[zTestFlight]
{
        MODULE
        {
                name = LRTFFailure_AvionicsPartial
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = Partial Avionics Control
                severity = minor
                weight = 16
                failureType = hardware
        }
}
@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsThrustJam[?rue]]]:FOR[zTestFlight]
{
        MODULE
        {
                name = LRTFFailure_AvionicsThrustJam
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = Jammed Thruster
                severity = minor
                weight = 16
                failureType = hardware
        }
}
@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsTotal[?rue]]]:FOR[zTestFlight]
{
        MODULE
        {
                name = LRTFFailure_AvionicsTotal
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = Total Loss Of Avionics
                severity = major
                includeAxisInPAW = false
                weight = 2
                failureType = hardware
        }
}
@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsSAS[?rue]]]:FOR[zTestFlight]
{
        MODULE
        {
                name = LRTFFailure_AvionicsSAS
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = SAS Failure
                severity = Major
                weight = 2
                failureType = software
        }
}
@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsReactionWheel[?rue]]]:FOR[zTestFlight]
{
        MODULE
        {
                name = LRTFFailure_ReactionBroken
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = Broken Reaction Wheel
                severity = minor
                weight = 16
                failureType = hardware
        }
        MODULE
        {
                name = LRTFFailure_ReactionTorque
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                @duFail *= #$../LRTFAVIONICS,0/mannedDUMulti$
                duRepair = 250
                @duRepair *= #$../LRTFAVIONICS,0/mannedDUMulti$
                failureTitle = Torque Alignment Errors
                severity = minor
                weight = 32
                failureType = software
        }
}
@PART[*]:HAS[@LRTFAVIONICS:HAS[#avionicsBattery[?rue]]]:FOR[zTestFlight]
{
        MODULE
        {
                name = LRTFFailure_ResourceLeak
                configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                duRepair = 250
                failureTitle = Short Circuit
                severity = minor
                weight = 16
                initialAmount = 0
                perSecondAmount = 0.05
                resourceToLeak = ElectricCharge
                includeResourceInPAW = false
                failureType = hardware
        }
		MODULE
        {
        		name = LRTFFailure_ResourcePump
				configuration = #$../LRTFAVIONICS,0/alias$
                duFail = 100
                duRepair = 250
                failureTitle = Battery Failure
				weight = 2
				severity = major
				resourceName = ElectricCharge
				failureType = hardware
				drainResource = true
				includeResourceInPAW = false
        }
}

//Cleanup
@PART[*]:HAS[@LRTFAVIONICS]:AFTER[zTestFlight]
{
	-LRTFAVIONICS {}
}